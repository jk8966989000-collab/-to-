<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>月影奔行者</title>
<style>
  body {
    margin: 0;
    background: #111;
    overflow: hidden;
    touch-action: manipulation;
    font-family: sans-serif;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: linear-gradient(#1a1a2e, #000);
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let groundY = canvas.height * 0.8;

let player = {
  x: 80,
  y: groundY,
  size: 40,
  vy: 0,
  jumpPower: -18,
  gravity: 0.9,
  onGround: true
};

let obstacles = [];
let speed = 6;
let score = 0;
let gameOver = false;

function jump() {
  if (player.onGround && !gameOver) {
    player.vy = player.jumpPower;
    player.onGround = false;
  }
}

window.addEventListener("touchstart", jump);
window.addEventListener("mousedown", jump);

function spawnObstacle() {
  obstacles.push({
    x: canvas.width,
    width: 40,
    height: 60
  });
}

setInterval(() => {
  if (!gameOver) spawnObstacle();
}, 1500);

function update() {
  if (gameOver) return;

  player.vy += player.gravity;
  player.y += player.vy;

  if (player.y >= groundY) {
    player.y = groundY;
    player.vy = 0;
    player.onGround = true;
  }

  obstacles.forEach(o => o.x -= speed);
  obstacles = obstacles.filter(o => o.x + o.width > 0);

  obstacles.forEach(o => {
    if (
      player.x < o.x + o.width &&
      player.x + player.size > o.x &&
      player.y < groundY &&
      player.y + player.size > groundY - o.height
    ) {
      gameOver = true;
    }
  });

  score++;
  speed += 0.0005;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 地面
  ctx.fillStyle = "#333";
  ctx.fillRect(0, groundY + player.size, canvas.width, 4);

  // 玩家
  ctx.fillStyle = "#fff";
  ctx.fillRect(player.x, player.y - player.size, player.size, player.size);

  // 障礙
  ctx.fillStyle = "#888";
  obstacles.forEach(o => {
    ctx.fillRect(o.x, groundY - o.height, o.width, o.height);
  });

  // 分數
  ctx.fillStyle = "#aaa";
  ctx.font = "20px sans-serif";
  ctx.fillText(`距離 ${Math.floor(score / 10)} m`, 20, 40);

  if (gameOver) {
    ctx.fillStyle = "#fff";
    ctx.font = "36px sans-serif";
    ctx.fillText("遊戲結束", canvas.width / 2 - 70, canvas.height / 2);
    ctx.font = "20px sans-serif";
    ctx.fillText("點一下重新整理", canvas.width / 2 - 80, canvas.height / 2 + 40);
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>

</body>
</html>
